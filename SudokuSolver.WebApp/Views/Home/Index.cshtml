@{
    ViewData["Title"] = "Sudoku Solver";
}

<div class="container-fluid">
    <div class="row justify-content-center">
        <div class="col-12 col-lg-8 col-xl-6">
            <div class="text-center mb-4">
                <h1 class="display-4 text-primary">Sudoku Solver</h1>
                <p class="lead text-muted">Enter your puzzle and let the AI solve it for you!</p>
            </div>

            <!-- Sudoku Grid -->
            <div class="card shadow-sm">
                <div class="card-body p-2">
                    <div class="sudoku-outer-container">
                        <div id="sudoku-grid" class="sudoku-grid">
                            <!-- Grid will be generated by JavaScript -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- Control Buttons -->
            <div class="text-center mt-4">
                <button id="solve-btn" class="btn btn-primary btn-lg me-3" disabled>
                    <i class="fas fa-magic me-2"></i>Solve Puzzle
                </button>
                <button id="clear-btn" class="btn btn-outline-secondary btn-lg me-3">
                    <i class="fas fa-eraser me-2"></i>Clear Grid
                </button>
                <button id="sample-btn" class="btn btn-outline-info btn-lg">
                    <i class="fas fa-lightbulb me-2"></i>Load Sample
                </button>
            </div>

            <!-- Status Messages -->
            <div id="status-message" class="alert mt-3" style="display: none;"></div>
        </div>
    </div>
</div>

<!-- Loading Modal -->
<div class="modal fade" id="loadingModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-body text-center p-4">
                <div class="spinner-border text-primary mb-3" role="status">
                    <span class="visually-hidden">Loading...</span>
                </div>
                <h5 class="mb-2">Solving Puzzle...</h5>
                <p class="text-muted mb-0">Please wait while our AI analyzes and solves your Sudoku puzzle.</p>
            </div>
        </div>
    </div>
</div>

@section Styles {
    <style>
        .sudoku-outer-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            overflow: visible;
            padding: 10px;
        }
        .sudoku-grid {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            gap: 1px;
            background-color: #333;
            border: 2px solid #333;
            width: min(450px, 90vw);
            height: min(450px, 90vw);
            margin: 0 auto;
            overflow: visible;
        }
        .sudoku-cell {
            aspect-ratio: 1;
            background-color: white;
            border: none;
            text-align: center;
            font-size: clamp(0.8rem, 2.5vw, 1.2rem);
            font-weight: 500;
            transition: all 0.2s ease;
            width: 100%;
            height: 100%;
            box-sizing: border-box;
        }
        .sudoku-cell:focus {
            outline: none;
            background-color: #e3f2fd;
            box-shadow: inset 0 0 0 2px #2196f3;
        }
        .sudoku-cell.original {
            background-color: #f5f5f5;
            font-weight: 700;
            color: #333;
        }
        .sudoku-cell.solved {
            background-color: #e8f5e8;
            color: #2e7d32;
        }
        .sudoku-cell.error {
            background-color: #ffebee;
            color: #c62828;
        }
        /* 3x3 box borders */
        .sudoku-cell:nth-child(3n) {
            border-right: 2px solid #333;
        }
        .sudoku-cell:nth-child(9n) {
            border-right: none;
        }
        .sudoku-grid > input:nth-child(n+19):nth-child(-n+27),
        .sudoku-grid > input:nth-child(n+46):nth-child(-n+54) {
            border-bottom: 2px solid #333;
        }
        @@media (max-width: 576px) {
            .sudoku-grid {
                width: min(350px, 95vw);
                height: min(350px, 95vw);
            }
            .sudoku-cell {
                font-size: clamp(0.7rem, 3vw, 1rem);
            }
        }
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        .alert {
            border-radius: 8px;
        }
    </style>
}

@section Scripts {
    <script>
        class SudokuSolver {
            constructor() {
                this.grid = new Array(81).fill(0);
                this.originalValues = new Set();
                this.isSolving = false;
                this.initializeGrid();
                this.bindEvents();
            }

            initializeGrid() {
                const gridContainer = document.getElementById('sudoku-grid');
                gridContainer.innerHTML = '';

                for (let i = 0; i < 81; i++) {
                    const cell = document.createElement('input');
                    cell.type = 'number';
                    cell.min = '0';
                    cell.max = '9';
                    cell.className = 'sudoku-cell';
                    cell.dataset.index = i;
                    
                    cell.addEventListener('input', (e) => this.handleCellInput(e, i));
                    cell.addEventListener('keydown', (e) => this.handleKeyDown(e, i));
                    
                    gridContainer.appendChild(cell);
                }
            }

            handleCellInput(event, index) {
                let value = parseInt(event.target.value) || 0;
                
                // Ensure value is between 0 and 9
                if (value < 0) value = 0;
                if (value > 9) value = 9;
                
                this.grid[index] = value;
                event.target.value = value === 0 ? '' : value;
                
                // Update original values set
                if (value > 0) {
                    this.originalValues.add(index);
                } else {
                    this.originalValues.delete(index);
                }
                
                this.updateSolveButton();
                this.clearStatus();
            }

            handleKeyDown(event, index) {
                const currentValue = this.grid[index];
                
                switch (event.key) {
                    case 'ArrowUp':
                        event.preventDefault();
                        this.navigateToCell(index - 9);
                        break;
                    case 'ArrowDown':
                        event.preventDefault();
                        this.navigateToCell(index + 9);
                        break;
                    case 'ArrowLeft':
                        event.preventDefault();
                        if (index % 9 !== 0) {
                            this.navigateToCell(index - 1);
                        }
                        break;
                    case 'ArrowRight':
                        event.preventDefault();
                        if (index % 9 !== 8) {
                            this.navigateToCell(index + 1);
                        }
                        break;
                    case 'Backspace':
                    case 'Delete':
                        if (currentValue > 0) {
                            this.grid[index] = 0;
                            event.target.value = '';
                            this.originalValues.delete(index);
                            this.updateSolveButton();
                            this.clearStatus();
                        }
                        break;
                }
            }

            navigateToCell(index) {
                if (index >= 0 && index < 81) {
                    const cells = document.querySelectorAll('.sudoku-cell');
                    cells[index].focus();
                }
            }

            updateSolveButton() {
                const solveBtn = document.getElementById('solve-btn');
                const hasValues = this.grid.some(value => value > 0);
                solveBtn.disabled = !hasValues || this.isSolving;
            }

            async solvePuzzle() {
                if (this.isSolving) return;
                
                this.isSolving = true;
                this.updateSolveButton();
                this.showLoading();
                this.clearStatus();

                try {
                    const response = await fetch('/api/sudoku/solve', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ grid: this.grid })
                    });

                    const result = await response.json();

                    if (response.ok) {
                        // Check if the solution contains actual values
                        const hasSolution = result.grid && result.grid.some(value => value > 0);
                        
                        if (hasSolution) {
                            this.displaySolution(result.grid);
                            this.showStatus('Puzzle solved successfully!', 'success');
                        } else {
                            this.showStatus('Unable to solve this puzzle. It may be invalid or too difficult.', 'warning');
                        }
                    } else {
                        this.showStatus(result.error || 'Failed to solve puzzle', 'danger');
                    }
                } catch (error) {
                    console.error('Error solving puzzle:', error);
                    this.showStatus('An error occurred while solving the puzzle', 'danger');
                } finally {
                    this.hideLoading();
                    this.isSolving = false;
                    this.updateSolveButton();
                }
            }

            displaySolution(solutionGrid) {
                const cells = document.querySelectorAll('.sudoku-cell');
                
                cells.forEach((cell, index) => {
                    const value = solutionGrid[index];
                    const isOriginal = this.originalValues.has(index);
                    
                    cell.value = value;
                    cell.className = 'sudoku-cell';
                    
                    if (isOriginal) {
                        cell.classList.add('original');
                    } else if (value > 0) {
                        cell.classList.add('solved');
                    }
                    
                    cell.readOnly = true;
                });
            }

            clearGrid() {
                this.grid = new Array(81).fill(0);
                this.originalValues.clear();
                
                const cells = document.querySelectorAll('.sudoku-cell');
                cells.forEach(cell => {
                    cell.value = '';
                    cell.className = 'sudoku-cell';
                    cell.readOnly = false;
                });
                
                this.updateSolveButton();
                this.clearStatus();
                
                // Focus on first cell
                cells[0].focus();
            }

            loadSample() {
                const samplePuzzle = [
                    5,3,0,0,7,0,0,0,0,
                    6,0,0,1,9,5,0,0,0,
                    0,9,8,0,0,0,0,6,0,
                    8,0,0,0,6,0,0,0,3,
                    4,0,0,8,0,3,0,0,1,
                    7,0,0,0,2,0,0,0,6,
                    0,6,0,0,0,0,2,8,0,
                    0,0,0,4,1,9,0,0,5,
                    0,0,0,0,8,0,0,7,9
                ];
                
                this.grid = [...samplePuzzle];
                this.originalValues.clear();
                
                const cells = document.querySelectorAll('.sudoku-cell');
                cells.forEach((cell, index) => {
                    const value = samplePuzzle[index];
                    cell.value = value === 0 ? '' : value;
                    cell.className = 'sudoku-cell';
                    cell.readOnly = false;
                    
                    if (value > 0) {
                        this.originalValues.add(index);
                        cell.classList.add('original');
                    }
                });
                
                this.updateSolveButton();
                this.clearStatus();
            }

            showLoading() {
                const modalElement = document.getElementById('loadingModal');
                const modal = new bootstrap.Modal(modalElement);
                modal.show();
            }

            hideLoading() {
                const modalElement = document.getElementById('loadingModal');
                const modal = bootstrap.Modal.getInstance(modalElement) || new bootstrap.Modal(modalElement);
                modal.hide();
                
                // Fallback: manually hide the modal if Bootstrap method fails
                setTimeout(() => {
                    if (modalElement.classList.contains('show')) {
                        modalElement.classList.remove('show');
                        modalElement.style.display = 'none';
                        document.body.classList.remove('modal-open');
                        const backdrop = document.querySelector('.modal-backdrop');
                        if (backdrop) {
                            backdrop.remove();
                        }
                    }
                }, 100);
            }

            showStatus(message, type) {
                const statusElement = document.getElementById('status-message');
                statusElement.textContent = message;
                statusElement.className = `alert alert-${type} mt-3`;
                statusElement.style.display = 'block';
            }

            clearStatus() {
                const statusElement = document.getElementById('status-message');
                statusElement.style.display = 'none';
            }

            bindEvents() {
                document.getElementById('solve-btn').addEventListener('click', () => this.solvePuzzle());
                document.getElementById('clear-btn').addEventListener('click', () => this.clearGrid());
                document.getElementById('sample-btn').addEventListener('click', () => this.loadSample());
            }
        }

        // Initialize the solver when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new SudokuSolver();
        });
    </script>
}